design01：接口单一职责原则

=====================================================================
design02：
依赖倒转原则(Dependence Inversion Principle)是指：
1) 高层模块不应该依赖低层模块，二者都应该依赖其抽象
2) 抽象不应该依赖细节，细节应该依赖抽象
3) 依赖倒转(倒置)的中心思想是面向接口编程
4) 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，
抽象的东西要稳定的
多。以抽象为基础搭建的架构比以细节为基础的架构要稳定
的多。在java中，抽象
指的是接口或抽象类，细节就是具体的实现类
5) 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的
操作，把展现细节的
任务交给他们的实现类去完成
--------------------------------------------------
依赖关系传递的三种方式
1) 接口传递
2) 构造方法传递
3) setter方式传递

=====================================================================
design03: 开闭原则
1) 开闭原则（Open Closed Principle）是编程中最基础、最
重要的设计原则
2) 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，
对修改关闭(对使用
方)。用抽象构建框架，用实现扩展细节。
3) 当软件需要变化时，尽量通过扩展软件实体的行为来实现
变化，而不是通过修改已有的代码来实现变化。
4) 编程中遵循其它原则，以及使用设计模式的目的就是遵
循开闭原则。
=====================================================================
design04: 迪米特法则
1) 迪米特法则的核心是降低类之间的耦合
2) 但是注意：由于每个类都减少了不必要的依赖，
因此迪米特法则只是要求降低类间(对象间)耦合关
系， 并不是要求完全没有依赖关系

====================设计模式 Start=======================================

=====================================================================
design05  单例设计模式
所谓类的单例设计模式，就是采取一定的方法保证在整
个的软件系统中，对某个类
只能存在一个对象实例，并且该类只提供一个取得其对
象实例的方法(静态方法)。
比如Hibernate的SessionFactory，它充当数据存储源的
代理，并负责创建Session
对象。SessionFactory并不是轻量级的，一般情况下，一
个项目通常只需要一个
SessionFactory就够，这是就会使用到单例模式。
单例模式有八种方式：
1) 饿汉式(静态常量)
2) 饿汉式（静态代码块）
3) 懒汉式(线程不安全)
4) 懒汉式(线程安全，同步方法)
5) 懒汉式(线程安全，同步代码块)
6) 双重检查
7) 静态内部类
8) 枚举
=====================================================================
design06    工厂模式
--------------------
1) 工厂模式的意义
将实例化对象的代码提取出来，放到一个类中统一管理和维护，
达到和主项目的依赖关系的解耦。从而提高项目的扩展
和维护性。
2) 三种工厂模式 (简单工厂模式、工厂方法模式、抽象工厂模式)
3) 设计模式的依赖抽象原则
创建对象实例时，不要直接 new 类, 而是把这个new 类的动
作放在一个工厂的方法
中，并返回。有的书上说，变量不要直接持有具体类的引用。
不要让类继承具体类，而是继承抽象类或者是实现interface(接口)
不要覆盖基类中已经实现的方法。

factory1(传统方式)
factory2 简单工厂模式/静态工程模式
factory3  工厂方法模式
factory4  抽象工厂模式
=====================================================================
design07    适配器模式
---------------------
factory1 适配器模式
factory2 对象适配器模式
factory3  接口的适配器模式：接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，
当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，
有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，
实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行



类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。

对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。

接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可

=====================================================================
design08    装饰模式
=====================================================================
design09    代理模式
代理模式的应用场景：
如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。
使用代理模式，可以将功能划分的更加清晰，有助于后期维护！
========================================================================
design10      外观模式
如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，
这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！
========================================================================